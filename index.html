<!DOCTYPE html>
<html lang="en">
  <head>
    <title>p2.js Canvas example</title>
    <meta charset="utf-8">
    <script src="p2.js-master/build/p2.js"></script>
  </head>
  <body>

    <!-- The canvas, where we draw stuff -->
    <canvas width="600" height="400" id="myCanvas"></canvas>

    <script>
      var canvas, ctx, w, h,
          world, circleBody, planeBody, slopeVerts, slopeVerts2, spacedown;
      var levelDrawCallbacks = [];
      var collisionObjs = [];
      var shotsLeft = 3;
      var canShoot = true;
      init();
      animate();

      function init(){
        slopeVerts = generateSlope(0, 60, 30, 0, 30);
        slopeVerts2 = generateSlope(0, 60, 30, 0, 30);
        // Init canvas
        canvas = document.getElementById("myCanvas");
        w = canvas.width;
        h = canvas.height;

        ctx = canvas.getContext("2d");
        ctx.lineWidth = .5;

        // Init p2.js
        world = new p2.World();

        // Add a circle
        /*circleShape = new p2.Circle(5);
        circleBody = new p2.Body({ mass:4, position:[5,40] });
        circleShape.material = new p2.Material();
        circleBody.addShape(circleShape);
        circleBody.circleType = "circle1";
        world.addBody(circleBody);*/

        //create the main slope
        planeBody = new p2.Body({mass:0, position:[0,0]});
        planeBody.fromPolygon(slopeVerts);
       // planeBody.
        world.addBody(planeBody);
        //level ex
        var level = {
          houses: [
            {
              pos: {x: 65, y: 0},
              width: 20,
              height: 15,
              roofHeight: 10
            },
            {
              pos: {x: 40, y: 0},
              width: 10,
              height: 10,
              roofHeight: 10
            },
            {
              pos: {x: 20, y: 0},
              width: 5,
              height: 12,
              roofHeight: 10
            }
          ],
          width: 100
        }
        //Make a level object
        generateLevel(slopeVerts2[29], level, world);
        //spacebar handler
        window.onkeydown = function(e){
          if(e.keyCode == 32) {
            console.log('p');
            spacedown = true;
          }
        };
        window.onkeyup = function(e){
          if(e.keyCode == 32) {
            console.log('p');
            spacedown = false;
          }
        };
        world.on("beginContact", function(evt){
          if(evt.bodyA.circleType == "circle1") {
            var canAdd = true;
            collisionObjs.forEach(function(body){
              if(body == evt.bodyA)
                canAdd = false;
            });
            if(canAdd)
              collisionObjs.push(evt.bodyA);
          }
       /*   if(evt.bodyB.circleType == "circle1") {
            var canAdd = true;
            collisionObjs.forEach(function(body){
              if(body == evt.bodyB)
                canAdd = false;
            });
            if(canAdd)
              collisionObjs.push(evt.bodyB);
          }*/
        });
      }
      //Draws the circle
      //This is gonna go away when I make my own circles
      function drawCircle(circle){
        ctx.beginPath();
        var x = circle.position[0],
            y = circle.position[1],
            radius = circle.shapes[0].radius;
        ctx.arc(x,y,radius,0,2*Math.PI);
        ctx.stroke();
      }

      function addCircle(r, m, p, type) {
        circleShape = new p2.Circle(r);
        circleBody = new p2.Body({ mass:m, position:p });
        circleShape.material = new p2.Material();
        circleBody.addShape(circleShape);
        circleBody.circleType = type;
        world.addBody(circleBody);
      }
      //this is a naughty little function that generates verts
      function generateSlope(x1, x2, y1, y2, verts) {
        var slope = [];
        var width = x2 - x1;
        var periods = .85;
        var amp = (y1 - y2)/2;
        var twoPI = 2 * 3.1415926;
        var frequency = twoPI/width * periods;
        var y3;
        
        slope[0] = [x1,y1];
        //magic
        for(var i = 1; i < verts; i++) {
          var tempX;
          var tempY;
          tempX = x1 + (x2 - x1)/verts * i;
          tempY = (12*(Math.cos(frequency*tempX)) - tempX/2);
          slope[i] = [tempX, tempY];
          
          if(i == verts - 1) {
            y3 = tempY;
          }
        }
        slope[verts] = [x2, y3 - 20];
        slope[verts + 1] = [x1, y3 - 20];
        //done
        return slope;
      }

      function drawRoof(roof) {
        console.log(roof);
        ctx.save();
        
        ctx.beginPath();
        ctx.translate(roof.position[0], roof.position[1]);
        ctx.rotate(roof.angle);
        
        ctx.moveTo(roof.concavePath[0][0], roof.concavePath[0][1]);
        ctx.lineTo(roof.concavePath[1][0], roof.concavePath[1][1]);
        ctx.lineTo(roof.concavePath[2][0], roof.concavePath[2][1]);
        ctx.closePath();
        ctx.stroke();
        
        ctx.restore();
      }

      function render(){
        // Clear the canvas
        ctx.clearRect(0,0,w,h);

        // Transform the canvas
        // Note that we need to flip the y axis since Canvas pixel coordinates
        // goes from top to bottom, while physics does the opposite.
        ctx.save();
        ctx.translate(w/4, h/2);  // Translate to the center
        ctx.scale(2, -2);       // Zoom in and flip y axis
        //Draw the start ramp
        ctx.beginPath();
        ctx.moveTo(slopeVerts2[0][0], slopeVerts2[0][1]);
        slopeVerts2.forEach(function(coords){
          ctx.lineTo(coords[0], coords[1]);
        });
        ctx.stroke();
        ctx.closePath();
        // Draw all bodies
        levelDrawCallbacks.forEach(function(draw){ draw(); });

        //drawCircle();
        world.bodies.forEach(function(body){
          if(body.circleType == "circle1" || body.circleType == "circle2"){
            drawCircle(body);
          } else if(body.type == "roof"){
            drawRoof(body);
            body.force[1] = -15;
          }
        });
        // Restore transform
        ctx.restore();
      }

      // Animation loop
      function animate(){
        requestAnimationFrame(animate);

        if(spacedown) {
           if(!canShoot) { 
            world.bodies.forEach(function(body){
              if(body.circleType == "circle1" ){
               body.force[1] = -100;
               body.force[0] = 5; 
              }
            });
          } else if(shotsLeft > 0){
            addCircle(2, 4, [5,40], "circle1");
            canShoot = false;
            shotsLeft --;
          }
        }
         //world.bodies[0].force[0] = 5;
        // Move physics bodies forward in time
        world.step(1/30);
        collisionObjs.forEach(function(obj){

          if(obj.position[0] > 60) {
            world.bodiesToBeRemoved.push(obj);
            addCircle(1, 2, [obj.position[0] + 2, obj.position[1] - 2], "circle2");
            addCircle(1, 2, [obj.position[0] - 2, obj.position[1] - 2], "circle2");
            addCircle(1, 2, [obj.position[0], obj.position[1]], "circle2");
            addCircle(1, 2, [obj.position[0] + 2, obj.position[1] + 2], "circle2");
            addCircle(1, 2, [obj.position[0] - 2, obj.position[1] + 2], "circle2");
            canShoot = true;
          } else {
            obj.shapes[0].radius += .1;
          }
        });
        collisionObjs = []; 
        // Render scene
        render();
      }
      //Adds physics objects into the world from a passed in lvl obj
      //also adds draw callbacks to be drawn by canvas
      function generateLevel(start, lvl, world) {
        //Draw callback for the valley, hard coded mostly right now
        var startDist = 5;
        levelDrawCallbacks.push(function(){
          ctx.beginPath();
          ctx.moveTo(start[0] + startDist, start[1]);
          ctx.lineTo(start[0] + startDist + 10, start[1] - 20);
          ctx.lineTo(start[0] + startDist + lvl.width, start[1] - 20);
          ctx.lineTo(start[0] + startDist + 30 + lvl.width, start[1]);
          ctx.stroke();
          ctx.closePath();
        });
        //Split the valley into 3 triangles for the ball to collide with
        //Left
        /*
        var tri1 = new p2.Body({mass:0, position:[0,0]});
        tri1.fromPolygon([[start[0] + 30, start[1]], 
          [start[0] + 50, start[1] - 20], [start[0] + 30, start[1] - 20]]);

        world.addBody(tri1);
        //Middle
        var tri2 = new p2.Body({mass:0, position:[0,0]});
        tri2.fromPolygon([[start[0] + 50, start[1] - 20], 
          [start[0] + 50 + lvl.width, start[1] - 20], [start[0] + 30, start[1] - 40]]);

        world.addBody(tri2);*/
        //right
        
        var tri3 = new p2.Body({mass:0, position:[0,0]});
        tri3.fromPolygon([[start[0] + startDist, start[1]],
          [start[0] + startDist + 10, start[1] - 20],
          [start[0] + startDist + lvl.width, start[1] - 20],
          [start[0] + startDist + 30 + lvl.width, start[1]],
          [start[0] + startDist + 30 + lvl.width, start[1]-40],
          [start[0] + startDist + 10, start[1]-40]]);

        world.addBody(tri3);
        //this is where the house code that I haven't done yet starts
        lvl.houses.forEach(function(house){
          
          //Bottom left corner
          var xStart = start[0] + startDist + house.pos.x;
          var yStart = start[1] - 20;
          console.log(house);
          //Make main part of house
          var base = new p2.Body({mass:0, position:[0,0]});
          base.fromPolygon([[xStart, yStart], [xStart, yStart + house.height], 
            [xStart + house.width, yStart + house.height], [xStart + house.width, yStart]]);
          world.addBody(base);

          levelDrawCallbacks.push(function(){
            ctx.beginPath();
            ctx.moveTo(xStart, yStart);
            ctx.lineTo(xStart, yStart + house.height);
            ctx.lineTo(xStart + house.width, yStart + house.height);
            ctx.lineTo(xStart + house.width, yStart);
            ctx.stroke();
            ctx.closePath();
          });
          //Make Roof
          var roof = new p2.Body({mass:10, position:[0,0]});
          roof.fromPolygon([[xStart, yStart + house.height], 
            [xStart + house.width/2, yStart + house.height + house.roofHeight],
            [xStart + house.width, yStart + house.height]]);
          roof.type = "roof";

          world.addBody(roof);
          //Roof draw callback
          levelDrawCallbacks.push(function(){
           /* ctx.beginPath();
            ctx.moveTo(xStart, yStart + house.height + 1);
            ctx.lineTo(xStart + house.width/2, yStart + house.height + 1 + house.roofHeight);
            ctx.lineTo(xStart + house.width, yStart + house.height + 1);
            ctx.stroke();
            ctx.closePath();*/
          });

          
        });
      }
    </script>

  </body>
</html>