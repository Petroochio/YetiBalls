<!DOCTYPE html>
<html lang="en">
    <head>
        <title>Yeti Balls</title>
        <meta charset="utf-8">
        <script src="p2.js-master/build/p2.js"></script>
        <style>
            @font-face {
                font-family: snowcaps;
                src: url("assets/SnowtopCaps.otf");
            }
            
            canvas {
                border: 1px solid black;
            }
        </style>

    </head>
    <body>

        <!-- The canvas, where we draw stuff -->
        <canvas width="600" height="400" id="myCanvas"></canvas>
        <section id="audioControls">
            <audio id="bgMainMenu" src="media/mainmenu.mp3" controls loop></audio>
            <audio id="bgLevel" src="media/levelbg.wav" controls loop></audio>
            <audio id="effectControl" controls></audio>
            <audio id="yetiFree" src="media/cagebreak.wav" controls></audio>
            <audio id="levelWin" src="media/levelwin.mp3" controls></audio>
            <audio id="levelLose" src="media/levelose.mp3" controls></audio>
        </section>

        <script>
        "use strict";
        (function(){
            //constants
            var WORLD_SPEED = 30;
            var YETI_POWER = 100;
            var gameState = "MAIN_MENU";
            var levelState = "IDLE";
            var lastTime = 0;
            /*
            Game States:
            - MAIN_MENU
            - LEVEL_SELECT
            - GAME_LOOP
                - LOADING
                - IDLE
                - BALL_ACTIVE
            - LEVEL_LOST
            - LEVEL_WON
            
            Button IDs:
            - play
            - replay
            - next
            - menu
            - int
            */
            //pretty transitions
            var transXplus = 2;
            var transYplus = 2;

            var canvas, ctx, w, h, lastTime, ballImg, triImg, recImg, babyFroz, babyFree, menuIcon, replayIcon, nextIcon, snowflakeOutlineImg, snowflakeFillImg, levelComplete,
            world, circleBody, planeBody, slopeVerts, slopeVerts2, spacedown, currentLevel, levelScore;
            var mainBGAudio, effectAudio, levelBGAudio, yetiFreeAudio, levelWinAudio, levelLoseAudio;
            var effectSounds = ["snowballHit.wav", "snowballHit.wav", "snowballHit.wav", "snowballHit.wav"], currentEffect;

            var levelDrawCallbacks = [];
            var collisionObjs = [];
            var shotsLeft = 100, endLife = 300;
            var canShoot = true;
            var canFire = true;
            var babyStates = [];
            var buttons = [];
            var levels = [];
            init();
            animate();

            function init(){
                //remove in final version
                localStorage.removeItem('levelsData');
                
                //Load Images
                ballImg = new Image();
                ballImg.src = "assets/ball1.png";

                babyFroz = new Image();
                babyFroz.src = "assets/babycaged.png"

                babyFree = new Image();
                babyFree.src = "assets/babyfree.png";
                
                menuIcon = new Image();
                menuIcon.src = "assets/menuIcon.png";
                
                replayIcon = new Image();
                replayIcon.src = "assets/replayIcon.png";
                
                nextIcon = new Image();
                nextIcon.src = "assets/nextIcon.png";

                recImg = new Image();
                recImg.src = "assets/rect.png";

                triImg = new Image();
                triImg.src = "assets/tri.png";
                
                snowflakeOutlineImg = new Image();
                snowflakeOutlineImg.src = "assets/snowflakeOutline.png";
                
                snowflakeFillImg = new Image();
                snowflakeFillImg.src = "assets/snowflakeFill.png";
                
                //load sounds
                mainBGAudio = document.querySelector("#bgMainMenu");
                mainBGAudio.volume = 0.5;
                levelBGAudio = document.querySelector("#bgLevel");
                levelBGAudio.volume = 0.25;
                levelWinAudio = document.querySelector("#levelWin");
                levelLoseAudio = document.querySelector("#levelLose");
                effectAudio = document.querySelector("#effectControl");
                currentEffect = 0;
                yetiFreeAudio = document.querySelector("#yetiFree");
                
                slopeVerts = generateSlope(0, 60, 30, 0, 30);
                slopeVerts2 = generateSlope(0, 60, 30, 0, 30);

                // Init canvas
                canvas = document.getElementById("myCanvas");
                w = canvas.width;
                h = canvas.height;

                ctx = canvas.getContext("2d");
                ctx.lineWidth = .5;
                
                //levels
                levels = JSON.parse(localStorage.getItem('levelsData')) || [
                    {   
                        shapes: [],
                        text: [{
                            words: "wordy wordy",
                            pos: {x: 0, y:0},
                            size: 10,
                            color: "black"
                        }],
                        babies: [{
                                pos: {x: 20, y: 0}
                            }
                        ],
                        width: 70,
                        shots: 3,
                        valleyPos: {x: -10, y: -100},
                        slope: [],
                        start: [0,0],
                        completed: false,
                        snowflakes: 0,
                        par: 1,
                        connectingHill: true
                    },
                    {
                        shapes: [
                            {
                                pos: {x: 20, y: 0},
                                width: 15,
                                height: 14,
                                type: "tri"
                            },
                            {
                                pos: {x: 65, y: 0},
                                width: 15,
                                height: 14,
                                type: "tri"
                            }
                        ],
                        babies: [{
                                pos: {x: 40, y: 0}
                            }
                        ],
                        width: 100,
                        shots: 3,
                        valleyPos: {x: 115, y: -75},
                        slope: slopeVerts,
                        start: slopeVerts[29],
                        completed: false,
                        snowflakes: 0,
                        par: 1,
                        connectingHill: true
                    },
                    {
                        shapes: [
                            {
                                pos: {x: 65, y: 0},
                                width: 15,
                                height: 14,
                                type: "tri"
                            },
                            {
                                pos: {x: 40, y: 0},
                                width: 10,
                                height: 10,
                                type: "rect"
                            },
                            {
                                pos: {x: 20, y: 0},
                                width: 5,
                                height: 12,
                                type: "rect"
                            }
                        ],
                        babies: [{
                                pos: {x: 30, y:0}
                            }
                        ],
                        width: 100,
                        shots: 3,
                        valleyPos: {x: 115, y: -75},
                        slope: slopeVerts,
                        completed: false,
                        start: slopeVerts[29],
                        snowflakes: 0,
                        par: 2,
                        connectingHill: true
                    }
                ];
                localStorage.setItem('levelsData', JSON.stringify(levels));
                
                makeHUD();
                currentLevel = 0;
                levelScore = 0;
                //var clone = JSON.parse( JSON.stringify( levels[currentLevel] ) );
                //resetGame(clone);
                //spacebar handler
                window.onkeydown = function(e){
                    if(e.keyCode == 32) {
                        spacedown = true;
                    }
                };
                window.onkeyup = function(e){
                    if(e.keyCode == 32) {
                        spacedown = false;
                        if(canShoot)
                            canFire = true;
                    }
                };
                canvas.onmousedown = doMouseDown;
                canvas.onmousemove = doMouseMove;
            }
            
            function playEffect() {
                effectAudio.src = "media/" + effectSounds[currentEffect];
                effectAudio.play();
                currentEffect++;
                if(currentEffect == effectSounds.length-1) currentEffect = 0;
            }

            //Adds physics objects into the world from a passed in lvl obj
            //also adds draw callbacks to be drawn by canvas
            function generateLevel(start, lvl, world) {
                //Draw callback for the valley, hard coded mostly right now
                var xOffSet = 10;
                var yOffSet = 20;
                levelDrawCallbacks.push(function(){
                    ctx.fillStyle = "white";
                    ctx.beginPath();
                    ctx.moveTo(lvl.valleyPos.x, lvl.valleyPos.y);
                    ctx.lineTo(lvl.valleyPos.x + xOffSet, lvl.valleyPos.y - yOffSet);
                    ctx.lineTo(lvl.valleyPos.x + lvl.width, lvl.valleyPos.y - yOffSet);
                    ctx.lineTo(lvl.valleyPos.x + xOffSet + lvl.width, lvl.valleyPos.y);
                    
                    //GHETTO
                    ctx.lineTo(lvl.valleyPos.x + xOffSet + lvl.width, lvl.valleyPos.y-40);
                    ctx.lineTo(lvl.valleyPos.x, lvl.valleyPos.y-40);
                    ctx.lineTo(lvl.valleyPos.x, lvl.valleyPos.y);
                    ctx.fill();
                    
                    ctx.stroke();
                    ctx.closePath();
                });
                //right
                if(lvl.slope.length > 1) {
                    var playField = JSON.parse( JSON.stringify(lvl.slope));
                    //playField.push([lvl.valleyPos.x -1, lvl.valleyPos.y]);

                    var tempplaneBody = new p2.Body({mass:0, position:[0,0]});
                    tempplaneBody.fromPolygon(playField);
                    // planeBody.
                    world.addBody(tempplaneBody);
                }

                var tri3 = new p2.Body({mass:0, position:[0,0]});
                tri3.fromPolygon([[lvl.valleyPos.x, lvl.valleyPos.y],
                [lvl.valleyPos.x + xOffSet, lvl.valleyPos.y - yOffSet],
                [lvl.valleyPos.x + lvl.width, lvl.valleyPos.y - yOffSet],
                [lvl.valleyPos.x + xOffSet + lvl.width, lvl.valleyPos.y],
                [lvl.valleyPos.x + (xOffSet*3) + lvl.width, lvl.valleyPos.y-(yOffSet*2)],
                [lvl.valleyPos.x + xOffSet, lvl.valleyPos.y-(yOffSet*2)]]);

                world.addBody(tri3);
                
                if(lvl.connectingHill) {
                    //ramp shit goes here

                   /* var tri4 = new p2.Body({mass:0, position:[0,0]});
                    tri3.fromPolygon([[lvl.valleyPos.x -1, lvl.valleyPos.y],
                    lvl.start, [lvl.valleyPos.x -20, lvl.valleyPos.y]]);

                    world.addBody(tri4);    

                    levelDrawCallbacks.push(function(){
                        ctx.fillStyle = "white";
                        ctx.beginPath();
                        ctx.moveTo(lvl.valleyPos.x, lvl.valleyPos.y);
                        ctx.lineTo(lvl.valleyPos.x -1, lvl.valleyPos.y);
                        ctx.lineTo(lvl.valleyPos.x + lvl.width, lvl.valleyPos.y - yOffSet);
                        ctx.lineTo(lvl.valleyPos.x -20, lvl.valleyPos.y);
                        
                        ctx.stroke();
                        ctx.closePath();
                        //GHETTO
                        //ctx.lineTo(lvl.valleyPos.x + xOffSet + lvl.width, lvl.valleyPos.y-40);
                        ctx.fill();
                        
                    });*/
                }
                //this is where the house code that I haven't done yet starts
                lvl.shapes.forEach(function(shape){
                    //Bottom left corner
                    var xStart = lvl.valleyPos.x + shape.pos.x;
                    var yStart = lvl.valleyPos.y - yOffSet;
                    //Make main part of house
                    var body;
                    if(shape.type === "rect") {
                        body = new p2.Body({mass:1, position:[0,0]});
                        body.fromPolygon([[xStart, yStart], [xStart, yStart + shape.height], 
                        [xStart + shape.width, yStart + shape.height], [xStart + shape.width, yStart]]);
                        body.type = "rect";
                        world.addBody(body);
                    }
                    if(shape.type == "tri") {
                        body = new p2.Body({mass:1, position:[0,0]});
                        body.fromPolygon([[xStart, yStart], [xStart + shape.width/2, yStart + shape.height], 
                        [xStart + shape.width, yStart]]);
                        body.type = "tri";
                        world.addBody(body);
                    }
                    
                });

                lvl.babies.forEach(function(baby){
                    //addCircle(1, 5, ,"baby");
                    var circleShape = new p2.Circle(5);
                    var circleBody = new p2.Body({ mass:1, position:[lvl.valleyPos.x + baby.pos.x, lvl.valleyPos.y - yOffSet +baby.pos.y + 5] });
                    circleShape.material = new p2.Material();
                    circleBody.addShape(circleShape);
                    circleBody.circleType = "baby";
                    circleBody.lifeTime = 0;
                    circleBody.trapped = true;
                    world.addBody(circleBody);
                });
                if(lvl.text && lvl.text.length > 0){
                    lvl.text.forEach(function(text){
                        levelDrawCallbacks.push(function(){
                            ctx.save();
                            ctx.scale(1,-1);
                            ctx.textAlign = "center";
                            ctx.textBaseline = "middle";
                            for(var i = 0; i < buttons.length; i++) buttons[i].draw();
                            drawText(text.words, text.pos.x, text.pos.y, text.size, text.color);
                            ctx.restore();
                        });
                    });
                }
            }

            function makeButton(x, y, w, h, radius, id, active, buttonText, textColor, textSize) {
                var fillStyle;
                if(active) fillStyle = "#bcbcbc";
                else fillStyle = "#e8e8e8";
                var button = {
                    id: id,
                    x: x,
                    y: y,
                    w: w,
                    h: h,
                    radius: radius,
                    active: active,
                    fillStyle: fillStyle,
                    draw: function() {
                        ctx.save();
                        ctx.fillStyle = this.fillStyle;
                        ctx.beginPath();
                        ctx.moveTo(this.x + this.radius, this.y);
                        ctx.lineTo(this.x + this.w - this.radius, this.y);
                        ctx.quadraticCurveTo(this.x + this.w, this.y, this.x + this.w, this.y + this.radius);
                        ctx.lineTo(this.x + this.w, this.y + this.h - this.radius);
                        ctx.quadraticCurveTo(this.x + this.w, this.y + this.h, this.x + this.w - this.radius, this.y + this.h);
                        ctx.lineTo(this.x + this.radius, this.y + this.h);
                        ctx.quadraticCurveTo(this.x, this.y + this.h, this.x, this.y + this.h - this.radius);
                        ctx.lineTo(this.x, this.y + this.radius);
                        ctx.quadraticCurveTo(this.x, this.y, this.x + this.radius, this.y);
                        ctx.closePath();
                        ctx.fill();
                        if(this.id == "next") ctx.drawImage(nextIcon, this.x + (this.radius/2), this.y + (this.radius/2),
                                                            this.w - this.radius, this.h - this.radius);
                        else if(this.id == "replay") ctx.drawImage(replayIcon, this.x + (this.radius/2), this.y + (this.radius/2),
                                                                   this.w - this.radius, this.h - this.radius);
                        else if(this.id == "menu") ctx.drawImage(menuIcon, this.x + (this.radius/2), this.y + (this.radius/2),
                                                                 this.w - this.radius, this.h - this.radius);
                        else if(this.id === parseInt(this.id, 10)) {
                            //var width = (this.w);
                            //console.log(width);
                            drawText(buttonText, this.x + (this.w/2), this.y + textSize, textSize, textColor);
                            ctx.drawImage(snowflakeOutlineImg, this.x+3, this.y+this.h/2, this.w-5, 45);
                            ctx.drawImage(snowflakeFillImg, 0, 0, 245*levels[this.id].snowflakes, 122, this.x+3, this.y+this.h/2, (this.w-5)*levels[this.id].snowflakes, 45);
                        }
                        else drawText(buttonText, this.x + (this.w/2), this.y + (this.h/2), textSize, textColor);
                        //console.log(parseInt(this.id, 10));
                        ctx.restore();
                    }   
                };
                
                buttons.push(button);
            }
            
            function makeHUD() {
                buttons = [];
                switch(gameState) {
                        case "MAIN_MENU":
                            makeButton(canvas.width/2 - 50, canvas.height/2 - 20, 100, 40, 5, "play", true, "Play", "white", 32);
                            mainBGAudio.play();
                            break;
                        case "LEVEL_SELECT":
                            for(var i = 0; i < levels.length; i++) {
                                if(i == 0 || levels[i-1].completed) {
                                    makeButton(100 + (canvas.width/5 * i), 100,
                                               100, 100, 10,
                                               i, true,
                                               (i + 1), "black", 32);
                                } else {
                                    makeButton(100 + (canvas.width/5 * i), 100,
                                               100, 100, 10,
                                               i, levels[i].completed,
                                               (i + 1), "black", 32);
                                }
                            }
                            break;
                        case "GAME_LOOP":
                            makeButton(canvas.width-40, 10, 30, 30, 5, "replay", true, "r", "white", 16);
                            makeButton(canvas.width-80, 10, 30, 30, 5, "menu", true, "m", "white", 16);
                            break;
                        case "LEVEL_WON":
                        case "LEVEL_LOST":
                            makeButton(canvas.width/2-137.5, canvas.height/2+50, 75, 75, 10, "menu", true, "Level Select", "white", 16);
                            makeButton(canvas.width/2-37.5, canvas.height/2+50, 75, 75, 10, "replay", true, "Replay Level", "white", 16);
                            if(currentLevel < levels.length - 1 || levels.completed == true) {
                                makeButton(canvas.width/2+62.5, canvas.height/2+50, 75, 75, 10, "next", true, "Next Level", "white", 16);
                            } else {
                                makeButton(canvas.width/2+62.5, canvas.height/2+50, 75, 75, 10, "next", false, "Next Level", "white", 16);
                            }
                            break;
                }
            }

            function resetGame(lvl) {
                //slopeVerts = generateSlope(0, 60, 30, 0, 30);
                //slopeVerts2 = generateSlope(0, 60, 30, 0, 30);

                levelDrawCallbacks = [];
                collisionObjs = [];
                shotsLeft = lvl.shots;
                levelScore = 0;
                canShoot = true;
                canFire = true;
                levelComplete = false;
                /*levelDrawCallbacks.push(function(){
                  ctx.save();
                  ctx.fillStyle = "#c4e8f2";
                  ctx.fillRect(-w,h/2, w*2, -h/2);
                  ctx.restore();
                });*/
                if(lvl.slope.length > 1) {
                    levelDrawCallbacks.push(function(){
                      ctx.save();
                      //ctx.strokeStyle = "#d4f8f2";
                      //Draw the start ramp
                        
                        ctx.fillStyle = "white";
                        
                      ctx.beginPath();
                      ctx.moveTo(lvl.slope[1][0], lvl.slope[1][1]);
                      for(var i = 1; i < lvl.slope.length - 2; i++) {
                      
                          ctx.lineTo(lvl.slope[i][0], lvl.slope[i][1]);
                      }
                        //Ghetto fix
                        ctx.lineTo(60, -40);
                        ctx.lineTo(lvl.slope[1][0], -40);
                        ctx.lineTo(lvl.slope[1][0], lvl.slope[1][1]);
                        
                        ctx.fill();
                        
                      ctx.stroke();
                      ctx.closePath();

                      ctx.restore();
                    });
                }

                world = initWorld(lvl);
            }

            function initWorld(lvl) {
                var tempWorld;

                // Init p2.js
                tempWorld = new p2.World();

                //create the main slope
               
                //Make a level object
                generateLevel(lvl.start, lvl, tempWorld);

                tempWorld.on("beginContact", function(evt){
                    if(evt.bodyA.circleType == "circle1" || evt.bodyA.circleType == "circle2" ) {
                        var canAdd = true;
                        collisionObjs.forEach(function(body){
                            if(body == evt.bodyA)
                            canAdd = false;
                        });

                        if(canAdd)
                           collisionObjs.push(evt.bodyA);
                    }
                    if (evt.bodyA.circleType === "circle1" || evt.bodyA.circleType === "circle2" && evt.bodyB.circleType === "baby") {
                        evt.bodyB.trapped = false;
                        //babynoise
                    };
                });

                return tempWorld;
            }

            function doMouseMove(e) {
                var mouse = getMouse(e);
                switch(gameState) {
                    case "MAIN_MENU":
                    case "LEVEL_SELECT":
                    case "LEVEL_LOST":
                    case "LEVEL_WON":
                    case "GAME_LOOP":
                        for(var i = 0; i < buttons.length; i++) {
                            if(mouse.x >= buttons[i].x && mouse.x <= buttons[i].x+buttons[i].w &&
                            mouse.y >= buttons[i].y && mouse.y <= buttons[i].y+buttons[i].h && buttons[i].active) {
                                buttons[i].fillStyle = "#767676";
                            } else if(buttons[i].active) {
                                buttons[i].fillStyle = "#bcbcbc";
                            }
                        }
                        break;
                }
            }
            
            function doMouseDown(e) {
                var mouse = getMouse(e);

                switch(gameState) {
                    case "MAIN_MENU":
                        for(var i = 0; i < buttons.length; i++) {
                            if(mouse.x >= buttons[i].x && mouse.x <= buttons[i].x+buttons[i].w &&
                            mouse.y >= buttons[i].y && mouse.y <= buttons[i].y+buttons[i].h) {
                                gameState = "LEVEL_SELECT";
                                playEffect();
                                makeHUD();
                            }
                        }
                        break;
                    case "LEVEL_SELECT":
                        for(var i = 0; i < buttons.length; i++) {
                            if(mouse.x >= buttons[i].x && mouse.x <= buttons[i].x+buttons[i].w &&
                            mouse.y >= buttons[i].y && mouse.y <= buttons[i].y+buttons[i].h &&
                              buttons[i].active == true) {
                                currentLevel = parseInt(buttons[i].id);
                                
                                gameState = "GAME_LOOP";
                                playEffect();
                                mainBGAudio.pause();
                                mainBGAudio.currentTime = 0;
                                levelBGAudio.play();
                                makeHUD();
                                var clone = JSON.parse( JSON.stringify(levels[currentLevel]));
                                resetGame(clone);
                            }
                        }
                        break;
                    case "LEVEL_WON":
                    case "LEVEL_LOST":
                        for(var i = 0; i < buttons.length; i++) {
                            if(mouse.x >= buttons[i].x && mouse.x <= buttons[i].x+buttons[i].w &&
                            mouse.y >= buttons[i].y && mouse.y <= buttons[i].y+buttons[i].h) {
                                if(buttons[i].id == "menu") {
                                    gameState = "LEVEL_SELECT";
                                    levelBGAudio.pause();
                                    levelBGAudio.currentTime = 0;
                                    mainBGAudio.play();
                                    makeHUD();
                                } else if(buttons[i].id == "replay") {
                                    gameState = "GAME_LOOP";
                                    makeHUD();
                                    var clone = JSON.parse( JSON.stringify(levels[currentLevel]));
                                    resetGame(clone);
                                }else if(buttons[i].id == "next") {
                                    if(buttons[i].active) {
                                        gameState = "GAME_LOOP";
                                        makeHUD();
                                        currentLevel++;
                                        var clone = JSON.parse( JSON.stringify(levels[currentLevel]));
                                        resetGame(clone);
                                    }
                                }
                                playEffect();
                                levelWinAudio.pause();
                                levelWinAudio.currentTime = 0;
                                levelLoseAudio.pause();
                                levelLoseAudio.currentTime = 0;
                            }
                        }
                        break;
                    case "GAME_LOOP":
                        for(var i = 0; i < buttons.length; i++) {
                            if(mouse.x >= buttons[i].x && mouse.x <= buttons[i].x+buttons[i].w &&
                            mouse.y >= buttons[i].y && mouse.y <= buttons[i].y+buttons[i].h) {
                                if(buttons[i].id == "replay") {
                                    levelState = "IDLE";
                                    var clone = JSON.parse( JSON.stringify(levels[currentLevel]));
                                    resetGame(clone);
                                } else if(buttons[i].id == "menu") {
                                    levelState = "IDLE";
                                    gameState = "LEVEL_SELECT";
                                    levelBGAudio.pause();
                                    levelBGAudio.currentTime = 0;
                                    mainBGAudio.play();
                                    makeHUD();
                                }
                            }
                        }
                        break;
                }
            }

            function getMouse(mouse) {
                var x = mouse.pageX - mouse.target.offsetLeft;
                var y = mouse.pageY - mouse.target.offsetTop;
                return {x: x, y: y};
            }
            //Draws the circle
            //This is gonna go away when I make my own circles
            function drawCircle(circle, fill){
                var r = circle.shapes[0].radius;

                ctx.beginPath();
                var x = circle.position[0],
                y = circle.position[1],
                radius = circle.shapes[0].radius;
                ctx.arc(x,y,radius,0,2*Math.PI);
                ctx.lineWidth = 1;
                ctx.stroke();

                ctx.save();
                if(circle.circleType == "circle1" && spacedown) { ctx.shadowBlur = 20; ctx.shadowColor = "blue";}   
                ctx.translate(circle.position[0], circle.position[1]);
                ctx.rotate(circle.angle);
                ctx.drawImage(ballImg, -1*r, -1*r, r*2, r*2);
                ctx.restore();
            }

            function drawBaby(baby) {
                var r = baby.shapes[0].radius;

                if(baby.trapped) {
                    ctx.save();   
                    ctx.translate(baby.position[0], baby.position[1]);
                    ctx.rotate(baby.angle + 3.14);
                    ctx.drawImage(babyFroz, -1*r, -1*r, r*2, r*2);
                    ctx.restore();
                }else {
                    ctx.save();   
                    ctx.translate(baby.position[0], baby.position[1]);
                    ctx.rotate(baby.angle + 3.14);
                    ctx.drawImage(babyFree, -1*r, -1*r, r*2, r*2);
                    ctx.restore();
                }
            }

            function addCircle(r, m, p, type) {
                var circleShape = new p2.Circle(r);
                var circleBody = new p2.Body({ mass:m, position:p });
                circleShape.material = new p2.Material();
                circleBody.addShape(circleShape);
                circleBody.circleType = type;
                circleBody.lifeTime = 0;
                circleBody.trapped = true;
                world.addBody(circleBody);
            }
            //this is a naughty little function that generates verts
            function generateSlope(x1, x2, y1, y2, verts) {
                var slope = [];
                var width = x2 - x1;
                var periods = .85;
                var amp = (y1 - y2)/2;
                var twoPI = 2 * 3.1415926;
                var frequency = twoPI/width * periods;
                var y3;

                slope[0] = [x1,y1];
                //magic
                for(var i = 1; i < verts; i++) {
                    var tempX;
                    var tempY;
                    tempX = x1 + (x2 - x1)/verts * i;
                    tempY = (12*(Math.cos(frequency*tempX)) - tempX/2);
                    slope[i] = [tempX, tempY];

                    if(i == verts - 1) {
                        y3 = tempY;
                    }
                }
                slope[verts] = [x2, y3 - 20];
                slope[verts + 1] = [x1, y3 - 20];
                //done
                return slope;
            }

            function drawTri(tri) {
                ctx.save();

                ctx.beginPath();
                ctx.translate(tri.position[0], tri.position[1]);
                ctx.rotate(tri.angle);
                ctx.lineWidth = 1;
                ctx.moveTo(tri.concavePath[0][0], tri.concavePath[0][1]);
                ctx.lineTo(tri.concavePath[1][0], tri.concavePath[1][1]);
                ctx.lineTo(tri.concavePath[2][0], tri.concavePath[2][1]);
                ctx.closePath();
                ctx.stroke();
                ctx.save();
                ctx.rotate(3.14);
                var boxW = tri.concavePath[0][0] - tri.concavePath[2][0];
                var boxH = tri.concavePath[0][1] - tri.concavePath[1][1];
                
                ctx.drawImage(triImg, - boxW/2,-boxH/2 - 2.5,  boxW, boxH);
                ctx.restore();
                ctx.restore();
            }

            function drawBox(box) {
                ctx.save();

                ctx.translate(box.position[0], box.position[1]);
                ctx.rotate(box.angle);
                ctx.beginPath();
                ctx.moveTo(box.concavePath[0][0], box.concavePath[0][1]);
                ctx.lineTo(box.concavePath[1][0], box.concavePath[1][1]);
                ctx.lineTo(box.concavePath[2][0], box.concavePath[2][1]);
                ctx.lineTo(box.concavePath[3][0], box.concavePath[3][1]);
                ctx.closePath();
                ctx.stroke();
                ctx.save();
                ctx.rotate(3.14);
                var boxW = box.concavePath[0][0] - box.concavePath[2][0];
                var boxH = box.concavePath[0][1] - box.concavePath[2][1];
                ctx.drawImage(recImg, -boxW/2,-boxH/2,  boxW, boxH);
                
                ctx.restore();
                ctx.restore();
            }

            function render(){
                // Clear the canvas
                ctx.clearRect(0,0,w,h);
                //GHETTO BG COLOR
                if(gameState == "GAME_LOOP") {
                    ctx.fillStyle = "rgba(94, 181, 255, 0.68)";
                    ctx.fillRect(0, 0, w, h);
                }
                
                ctx.save();

                switch (gameState) {
                    case "MAIN_MENU":
                        ctx.save();
                        ctx.textAlign = "center";
                        ctx.textBaseline = "middle";
                        for(var i = 0; i < buttons.length; i++) buttons[i].draw();
                        drawText("Yeti Balls", canvas.width/2, canvas.height/2 - 40, 34, "black");
                        ctx.restore();
                        break;
                    case "LEVEL_SELECT" :
                        ctx.save();
                        ctx.textAlign = "center";
                        ctx.textBaseline = "middle";
                        for(var i = 0; i < buttons.length; i++) buttons[i].draw();
                        drawText("Level Select", canvas.width/2, 50, 34, "black");
                        ctx.restore();
                        break;
                    case "GAME_LOOP" :
                        var transX = w/2;
                        var transY = h/2;
                        var scaleMult = 1;


                        for(var i = 0; i < buttons.length; i++) buttons[i].draw();
                        
                        world.bodies.forEach(function(body){
                            if(body.circleType == "circle1" ){
                                //if(body.position[0] > 60) 
                                    scaleMult = scaleMult - lerp(60, 60 + levels[currentLevel].width, body.position[0]);
                                //transX = 20-body.position[0];
                                //transY = h/3 + body.position[1];
                                scaleMult = scaleMult < .7 ? .7 : scaleMult;
                                transX -= body.position[0] *4* scaleMult;
                                transY += body.position[1] *4* scaleMult;
                            }
                        });

                        // Transform the canvas
                        // Note that we need to flip the y axis since Canvas pixel coordinates
                        // goes from top to bottom, while physics does the opposite.
                        if(!canShoot) {ctx.translate(transX, transY);} else {ctx.translate(w/4, h/2);}

                       if(canShoot) ctx.scale(1.5, -1.5);
                        else ctx.scale(4*scaleMult, -4*scaleMult);
                        // Draw all bodies
                        levelDrawCallbacks.forEach(function(draw){ draw(); });

                        //drawCircle();
                        world.bodies.forEach(function(body){
                            if(body.circleType == "circle2" ){
                                drawCircle(body);
                            }else if( body.circleType == "circle1"){

                                if(spacedown)
                                    drawCircle(body, 'blue');
                                else
                                    drawCircle(body);
                            }else if(body.circleType == "baby"){
                                drawBaby(body);
                            } else if(body.type == "tri"){
                              //  drawRoof(body);
                              drawTri(body);
                                body.force[1] = -15;
                            } else if(body.type == "rect"){
                                drawBox(body);
                                body.force[1] = -15;
                            }
                        });
                        
                        break;
                    case "LEVEL_WON":
                        ctx.save();
                        ctx.textAlign = "center";
                        ctx.textBaseline = "middle";
                        for(var i = 0; i < buttons.length; i++) buttons[i].draw();
                        drawText("Level Won", canvas.width/2, canvas.height/2 - 125, 34, "black");
                        ctx.drawImage(snowflakeOutlineImg, canvas.width/2-122.5, canvas.height/2-90);
                        ctx.drawImage(snowflakeFillImg, 0, 0, (245*levelScore), 122, canvas.width/2-122.5, canvas.height/2-90, (245*levelScore), 122);
                        ctx.restore();
                        break;
                    case "LEVEL_LOST":
                        ctx.save();
                        ctx.textAlign = "center";
                        ctx.textBaseline = "middle";
                        for(var i = 0; i < buttons.length; i++) buttons[i].draw();
                        drawText("Level Lost", canvas.width/2, canvas.height/2 - 125, 34, "black");
                        ctx.drawImage(snowflakeOutlineImg, canvas.width/2-122.5, canvas.height/2-90);
                        ctx.restore();
                        break;
                    default:
                        console.log("Render oops");
                }
                ctx.restore();
            }

            function lerp(min, max, val) {
                return (val-min)/max;
            }

            function drawText( text, x, y, size, color ) {
                ctx.font = "bold "+size+"px snowcaps";
                ctx.fillStyle = color;
                ctx.fillText(text, x, y);
            }

            function calculateDeltaTime() {
                var now, fps;
                now = (+ new Date);
                fps = 1000 / (now - lastTime);
                fps = clamp(fps, 12, 20);
                lastTime = now;
                return 1/fps;
            }

            function clamp( val, min, max ) {
                return Math.max(min, Math.max(max, val));
            }

            function animateGameLoop() {
                // Move physics bodies forward in time
                var dt = calculateDeltaTime();
                var et = 1/WORLD_SPEED;
                world.step(et);
                if(levelComplete) { levelState = "IDLE"; }
                switch (levelState) {
                    case "BALL_ACTIVE" :
                        endLife = 300;
                        if(spacedown) { 
                            world.bodies.forEach(function(body){
                                if(body.circleType == "circle1" ){
                                    body.force[1] = -YETI_POWER;
                                    body.force[0] = 5;
                                }
                            });
                        }
                        world.bodies.forEach(function(body){
                            if(body.circleType == "circle1" ){
                                body.lifeTime ++; 
                                if( body.position[1] < -900) {
                                    world.bodiesToBeRemoved.push(body);
                                    canShoot = true;
                                    levelState = "IDLE";  
                                }
                            }
                        });

                        //world.bodies[0].force[0] = 5;
                        collisionObjs.forEach(function(obj){
                        if((obj.position[0] > 60 || obj.position[1] < -40)  && obj.circleType == "circle1") {
                            playEffect();
                            world.bodiesToBeRemoved.push(obj);

                            addCircle(1, 2, [obj.position[0] + 2, obj.position[1] - 2], "circle2");
                            addCircle(1, 2, [obj.position[0] - 2, obj.position[1] - 2], "circle2");
                            addCircle(1, 2, [obj.position[0], obj.position[1]], "circle2");
                            addCircle(1, 2, [obj.position[0] + 2, obj.position[1] + 2], "circle2");
                            addCircle(1, 2, [obj.position[0] - 2, obj.position[1] + 2], "circle2");

                            canShoot = true;
                            levelState = "IDLE";
                            } else if(obj.circleType == "circle2" && obj.position[0] < 60 && obj.position[1] > -10){
                                //obj.shapes[0].radius += .1;
                                console.log('h');
                                world.bodiesToBeRemoved.push(obj);
                            } else if( obj.circleType == "circle1" && (obj.lifeTime > 300)) {
                                world.bodiesToBeRemoved.push(obj);
                                canShoot = true;
                                levelState = "IDLE";
                            }
                        });
                        collisionObjs = [];
                        break;
                    case "IDLE" :
                        var lifeZero = (endLife <= 0);
                        collisionObjs.forEach(function(obj){
                            if(obj.circleType == "circle2" && obj.position[0] < 60 && obj.position[1] > -10){
                                //obj.shapes[0].radius += .1;
                                world.bodiesToBeRemoved.push(obj);
                            }
                        });
                        collisionObjs = [];
                        if(testForRoundEnd() && lifeZero) {
                            gameState = "LEVEL_WON";
                            levelWinAudio.play();
                            levels[currentLevel].completed = true;
                            calculateSnowflakes();
                            localStorage.removeItem('levelsData');
                            localStorage.setItem('levelsData', JSON.stringify(levels));
                            makeHUD();
                        } else if(shotsLeft <= 0 && lifeZero) {
                            gameState = "LEVEL_LOST";
                            levelLoseAudio.play();
                            makeHUD();
                        }
                        if(spacedown) {
                            if(canFire && shotsLeft > 0 && !levelComplete){
                            addCircle(5, 4, [6,20], "circle1");
                            canShoot = false;
                            canFire = false;
                            shotsLeft --;
                            levelState = "BALL_ACTIVE";
                            }
                        }
                        endLife --;
                        break;
                    default:
                        console.log("LEVEL");
                }
                //This is the ghetto kids
                levelComplete = testForRoundEnd();
                if(levelComplete) { levelState = "IDLE"; }
            }

            //Tests for the end of a round
            function testForRoundEnd() {
                var complete = true;

                world.bodies.forEach(function(body){
                    if(body.circleType == "baby"){
                        if(body.trapped){
                            complete = false;
                        }
                    }
                });
                
                return complete;
            }
            
            function calculateSnowflakes() {
                var numerator = levels[currentLevel].shots - shotsLeft - levels[currentLevel].par;
                var denominator = levels[currentLevel].shots - levels[currentLevel].par;
                var rating = numerator/denominator;
                levelScore = 1.0 - rating;
                
                if(levels[currentLevel].shots - shotsLeft <= levels[currentLevel].par) levels[currentLevel].snowflakes = 1;
                else {
                    if(rating == 1) levels[currentLevel].snowflakes = 0;
                    else {
                        if(levels[currentLevel].snowflakes < levelScore) levels[currentLevel].snowflakes = levelScore;
                    }
                }
            }

            // Animation loop
            function animate(){
                requestAnimationFrame(animate);
                switch (gameState) {
                    case "GAME_LOOP" :
                        animateGameLoop();
                        break;
                    case "MAIN_MENU":
                    case "LEVEL_SELECT":
                    case "LEVEL_WON":
                    case "LEVEL_LOST":
                        if(buttons.length > 0) for(var i = 0; i < buttons.length; i++) buttons[i].draw();
                        break;
                    default:
                    console.log("oops"); 
                }
                // Render scene
                render();
            }
            
        }());

        </script>
    </body>
</html>